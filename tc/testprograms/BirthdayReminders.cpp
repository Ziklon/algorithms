#include <vector>
#include <map>
#include <set>
#include <queue>
#include <stack>
#include <bitset>
#include <algorithm>
#include <functional>
#include <numeric>
#include <utility>
#include <sstream>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstdlib>
#include <cstring>
#define all(v) (v).begin(),(v).end()
#define sz size()
#define REP(i,a,b) for(int i=int(a);i<int(b);i++)
#define fill(x,i) memset(x,i,sizeof(x))
#define cpresent(V,e) (find(all(V),(e))!=(V).end())
#define foreach(c,it) for(__typeof((c).begin()) it=(c).begin();it!=(c).end();it++)
using namespace std;
typedef long long ll;

struct node{
	int day,num,i,j;
	int Friend,occacion;
	
};
int getInd(vector<string>& v, string s){
	REP(i,0,v.sz)
		if(v[i]==s)return i;
	return 0;
}
bool orden(node p, node q){
	if(p.day!=q.day)return p.day<q.day;
	if(p.occacion!=q.occacion)return p.occacion<q.occacion;
	return p.Friend<q.Friend;
}

class BirthdayReminders {
public:vector <string> remind(vector <string> friendNames, vector <int> birthDates, int currentDate, vector <string> occasions, vector <int> days, int k) {	
		vector<node> v;
			
		REP(i,0,friendNames.sz){
			vector<int> cnt(occasions.sz,0);
			REP(j,0,cnt.sz){				
				cnt[j]=(currentDate-birthDates[i]-1)/days[j];
			}
			REP(j,0,k)
				REP(p,0,occasions.sz){
					node nod;
					cnt[p]++;
					nod.day=(days[p]*(cnt[p])) +birthDates[i];
					if(nod.day<currentDate)continue;					
					nod.Friend=i;
					nod.occacion=p;
					nod.num=(cnt[p]);
					v.push_back(nod);				
				}		
		}
		
		sort(all(v),orden);
		vector<string> ans;
		char buff[1024];
		cout<<v.sz<<endl;
		REP(i,0,k){
			if(i>=v.sz)break;
			sprintf(buff,"%d. %s %s (%d)",v[i].day,friendNames[v[i].Friend].c_str(),occasions[v[i].occacion].c_str(),v[i].num);
			//printf("%s\n",buff);
			
			ans.push_back(buff);
		}
		return ans;
						
	}
	//Powered by [Ziklon]
};
// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, vector <int> p1, int p2, vector <string> p3, vector <int> p4, int p5, bool hasAnswer, vector <string> p6) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p1.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p1[i];
	}
	cout << "}" << "," << p2 << "," << "{";
	for (int i = 0; int(p3.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p3[i] << "\"";
	}
	cout << "}" << "," << "{";
	for (int i = 0; int(p4.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << p4[i];
	}
	cout << "}" << "," << p5;
	cout << "]" << endl;
	BirthdayReminders *obj;
	vector <string> answer;
	obj = new BirthdayReminders();
	clock_t startTime = clock();
	answer = obj->remind(p0, p1, p2, p3, p4, p5);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << "{";
		for (int i = 0; int(p6.size()) > i; ++i) {
			if (i > 0) {
				cout << ",";
			}
			cout << "\"" << p6[i] << "\"";
		}
		cout << "}" << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << "{";
	for (int i = 0; int(answer.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << answer[i] << "\"";
	}
	cout << "}" << endl;
	if (hasAnswer) {
		if (answer.size() != p6.size()) {
			res = false;
		} else {
			for (int i = 0; int(answer.size()) > i; ++i) {
				if (answer[i] != p6[i]) {
					res = false;
				}
			}
		}
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	vector <int> p1;
	int p2;
	vector <string> p3;
	vector <int> p4;
	int p5;
	vector <string> p6;
	
	{
	// ----- test 0 -----
	string t0[] = {"John","Jack","Bill"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {50,100,150};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 500;
	string t3[] = {"birthday","decimal birthday","binary birthday"};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	int t4[] = {365,1000,512};
			p4.assign(t4, t4 + sizeof(t4) / sizeof(t4[0]));
	p5 = 10;
	string t6[] = {"515. Bill birthday (1)","562. John binary birthday (1)","612. Jack binary birthday (1)","662. Bill binary birthday (1)","780. John birthday (2)","830. Jack birthday (2)","880. Bill birthday (2)","1050. John decimal birthday (1)","1074. John binary birthday (2)","1100. Jack decimal birthday (1)"};
			p6.assign(t6, t6 + sizeof(t6) / sizeof(t6[0]));
	all_right = KawigiEdit_RunTest(0, p0, p1, p2, p3, p4, p5, true, p6) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"Zero","Two","Three"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {0,2,3};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 24;
	string t3[] = {"threeday","twoday"};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	int t4[] = {3,2};
			p4.assign(t4, t4 + sizeof(t4) / sizeof(t4[0]));
	p5 = 10;
	string t6[] = {"24. Zero threeday (8)","24. Three threeday (7)","24. Zero twoday (12)","24. Two twoday (11)","25. Three twoday (11)","26. Two threeday (8)","26. Zero twoday (13)","26. Two twoday (12)","27. Zero threeday (9)","27. Three threeday (8)"};
			p6.assign(t6, t6 + sizeof(t6) / sizeof(t6[0]));
	all_right = KawigiEdit_RunTest(1, p0, p1, p2, p3, p4, p5, true, p6) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"Jessica Alba","Angelina Jolie","Paris Hilton","Britney Spears"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {4135,1980,4065,4353};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 14091;
	string t3[] = {"Venus year","Earth year","Mars year","Jupiter year","Saturn year"};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	int t4[] = {225,365,687,4332,10760};
			p4.assign(t4, t4 + sizeof(t4) / sizeof(t4[0]));
	p5 = 20;
	string t6[] = {"14130. Angelina Jolie Venus year (54)","14190. Paris Hilton Venus year (45)","14208. Britney Spears Earth year (27)","14253. Britney Spears Venus year (44)","14260. Jessica Alba Venus year (45)","14285. Paris Hilton Earth year (28)","14346. Angelina Jolie Mars year (18)","14355. Angelina Jolie Venus year (55)","14355. Jessica Alba Earth year (28)","14370. Paris Hilton Mars year (15)","14390. Angelina Jolie Earth year (34)","14415. Paris Hilton Venus year (46)","14440. Jessica Alba Mars year (15)","14478. Britney Spears Venus year (45)","14485. Jessica Alba Venus year (46)","14573. Britney Spears Earth year (28)","14580. Angelina Jolie Venus year (56)","14640. Paris Hilton Venus year (47)","14650. Paris Hilton Earth year (29)","14658. Britney Spears Mars year (15)"};
			p6.assign(t6, t6 + sizeof(t6) / sizeof(t6[0]));
	all_right = KawigiEdit_RunTest(2, p0, p1, p2, p3, p4, p5, true, p6) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	int t1[] = {0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0,0};
			p1.assign(t1, t1 + sizeof(t1) / sizeof(t1[0]));
	p2 = 1000000;
	string t3[] = {"a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a","a"};
			p3.assign(t3, t3 + sizeof(t3) / sizeof(t3[0]));
	int t4[] = {1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1,1};
			p4.assign(t4, t4 + sizeof(t4) / sizeof(t4[0]));
	p5 = 100;
	all_right = KawigiEdit_RunTest(3, p0, p1, p2, p3, p4, p5, false, p6) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
