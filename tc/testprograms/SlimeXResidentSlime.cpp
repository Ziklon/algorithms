#include <vector>
#include <map>
#include <set>
#include <queue>
#include <bitset>
#include <algorithm>
#include <sstream>
#include <iostream>
#include <cstdio>
#include <cmath>
#include <cstring>
#include <ctime>
using namespace std;
#define INF 1<<20

int dx[]={0,0,1,-1};
int dy[]={1,-1,0,0};
int N,M;
int D[12][12];
int V[12];

int dp[12][12][1<<12];
vector<pair<int,int> >undead;

int bfs(int sx, int sy, int ex, int ey , vector<string>& board){
	int dis[55][55];
	for(int i=0;i<55;i++)for(int j=0;j<55;j++)dis[i][j]=INF;
	dis[sx][sy]=0;
	queue<pair<int,int> >Q;
	Q.push(make_pair(sx,sy));	
	while(!Q.empty()){
		pair<int,int> cur=Q.front();Q.pop();
		if(cur.first==ex && cur.second==ey)return dis[ex][ey];
		for(int i=0;i<4;i++){
			int X=cur.first+dx[i];
			int Y=cur.second+dy[i];
			if(min(X,Y)>=0 && X<N && Y<M && dis[X][Y]==INF && board[X][Y]!='#'){
				dis[X][Y]=dis[cur.first][cur.second]+1;
				Q.push(make_pair(X,Y));
			}
		}		
	}
	return INF;

}

int go(int idx, int rem, int mask){
	 if(__builtin_popcount(mask)==undead.size())return 0;
	 int& ref=dp[idx][rem][mask];
	 if(ref!=-1)return ref;
	 ref=INF;
	 for(int i=1;i<=undead.size();i++){
	 	if(mask&(1<<i))continue;
	 	if(D[idx][i]<rem){
	 		int steps=min(V[i],rem-D[idx][i]);
	 		ref=min(ref,D[idx][i]+go(i,steps,mask|(1<<i)));
	 	}	 	
	 }
	 return ref;
}



class SlimeXResidentSlime {
public:int exterminate(vector <string> field) {	
		int ans=1<<20;
		int cntUndead=0;
		N=field.size();
		M=field[0].size();
		int sx,sy;
		undead.clear();
		for(int i=0;i<field.size();i++)for(int j=0;j<M;j++)if(isdigit(field[i][j])){
			cntUndead++;
			V[cntUndead]=field[i][j]-'0';
			undead.push_back(make_pair(i,j));
		}		
		if(cntUndead>9)return -1;
		
		for(int i=0;i<N;i++)for(int j=0;j<M;j++)if(field[i][j]=='$'){
			sx=i;sy=j;
		}
		
		for(int i=0;i<cntUndead;i++)D[0][i+1]=D[i+1][0]=bfs(sx,sy,undead[i].first,undead[i].second,field);
		
		for(int i=0;i<cntUndead;i++)
			for(int j=i+1;j<cntUndead;j++)
				D[i+1][j+1]=D[j+1][i+1]=bfs(undead[i].first,undead[i].second,undead[j].first,undead[j].second,field);
				
		memset(dp,-1,sizeof dp);
		
		for(int i=1;i<=cntUndead;i++){
			ans=min(ans,D[0][i]+go(i,V[i],1<<i));
		}
		if(ans>=INF)return -1;
		
		
		return ans;		
	}
};
// BEGIN KAWIGIEDIT TESTING
// Generated by KawigiEdit 2.1.8 (beta) modified by pivanof
#include <iostream>
#include <string>
#include <vector>
using namespace std;
bool KawigiEdit_RunTest(int testNum, vector <string> p0, bool hasAnswer, int p1) {
	cout << "Test " << testNum << ": [" << "{";
	for (int i = 0; int(p0.size()) > i; ++i) {
		if (i > 0) {
			cout << ",";
		}
		cout << "\"" << p0[i] << "\"";
	}
	cout << "}";
	cout << "]" << endl;
	SlimeXResidentSlime *obj;
	int answer;
	obj = new SlimeXResidentSlime();
	clock_t startTime = clock();
	answer = obj->exterminate(p0);
	clock_t endTime = clock();
	delete obj;
	bool res;
	res = true;
	cout << "Time: " << double(endTime - startTime) / CLOCKS_PER_SEC << " seconds" << endl;
	if (hasAnswer) {
		cout << "Desired answer:" << endl;
		cout << "\t" << p1 << endl;
	}
	cout << "Your answer:" << endl;
	cout << "\t" << answer << endl;
	if (hasAnswer) {
		res = answer == p1;
	}
	if (!res) {
		cout << "DOESN'T MATCH!!!!" << endl;
	} else if (double(endTime - startTime) / CLOCKS_PER_SEC >= 2) {
		cout << "FAIL the timeout" << endl;
		res = false;
	} else if (hasAnswer) {
		cout << "Match :-)" << endl;
	} else {
		cout << "OK, but is it right?" << endl;
	}
	cout << "" << endl;
	return res;
}
int main() {
	bool all_right;
	all_right = true;
	
	vector <string> p0;
	int p1;
	
	{
	// ----- test 0 -----
	string t0[] = {"#1$",".2."};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 3;
	all_right = KawigiEdit_RunTest(0, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 1 -----
	string t0[] = {"$","1","1"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = -1;
	all_right = KawigiEdit_RunTest(1, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 2 -----
	string t0[] = {"$124"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 5;
	all_right = KawigiEdit_RunTest(2, p0, true, p1) && all_right;
	// ------------------
	}
	
	{
	// ----- test 3 -----
	string t0[] = {"$.#2","#..1"};
			p0.assign(t0, t0 + sizeof(t0) / sizeof(t0[0]));
	p1 = 6;
	all_right = KawigiEdit_RunTest(3, p0, true, p1) && all_right;
	// ------------------
	}
	
	if (all_right) {
		cout << "You're a stud (at least on the example cases)!" << endl;
	} else {
		cout << "Some of the test cases had errors." << endl;
	}
	return 0;
}
// END KAWIGIEDIT TESTING
//Powered by KawigiEdit 2.1.8 (beta) modified by pivanof!
